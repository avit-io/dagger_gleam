# ùå∏ Dagger Gleam

> ‚ö†Ô∏è **You are on `main`.** Active development happens on the [`dev`](../../tree/dev) branch.

**The type-safe, deferred execution SDK for Dagger, written in Gleam.**

Dagger Gleam treats your CI/CD pipelines as **data**. Instead of executing commands immediately, you build a **tree of operations** that the SDK then interprets and executes ‚Äî resolving dependencies automatically.

---

## The Core Concept: Data vs Execution

This SDK follows a strict separation between **description** and **execution**:

1. **The Tree (Data)** ‚Äî Using generated modules like `container` or `host`, you describe your pipeline. This stage is pure, side-effect free, and fast. You are just building a data structure.
2. **The Interpreter (Execution)** ‚Äî When you call a terminal function like `stdout`, the interpreter scans your tree, resolves any deferred dependencies (e.g. a local directory that needs mounting), and executes the final GraphQL query.

---

## Quick Start

### Prerequisites

```bash
nix develop  # enters the dev shell with gleam, erlang, dagger, and dgl
dgl generate # generates the DSL from Dagger's GraphQL schema
dagger run gleam test   # runs the test suite
```

### 1. Build your pipeline

```gleam
import dagger
import dagger/dsl/container as c
import dagger/dsl/host as h

pub fn main() {
  use client <- dagger.connect()

  let src = h.host() |> h.directory(".", with: h.none)

  let pipeline =
    c.container(with: fn(o) { o |> c.opt_platform("linux/amd64") })
    |> c.from("ghcr.io/gleam-lang/gleam:v1.14.0-erlang")
    |> c.with_mounted_directory("/src", src, with: c.none)
    |> c.with_exec(["gleam", "test"], with: c.none)

  use result <- c.stdout(pipeline, client)

  case result {
    Ok(out) -> io.println(out)
    Error(e) -> io.println_error(string.inspect(e))
  }
}
```

### 2. Run an example

```bash
dagger run gleam run -m examples/basic_pipeline
```

---

## Key Features

- **Zero-Config Contexts** ‚Äî Pass high-level objects (`Directory`, `Container`, `File`) as arguments directly. The interpreter detects them and resolves their GraphQL IDs automatically via `GDeferred` nodes.
- **Type Safety** ‚Äî Full Gleam types for enums, inputs, and scalars. No more guessing GraphQL field names.
- **Idiomatic Gleam** ‚Äî Leverages `use` syntax and CPS for a readable, functional flow with no hidden effects.
- **DSL Code Generation** ‚Äî Fully automated from Dagger's GraphQL introspection schema.

---

## Project Structure

```
codegen/                # dagger_codegen ‚Äî code generator (not published)
  src/dagger/
    types.gleam         # schema types (TypeDef, FieldDef, ArgDef)
    schema_decoder.gleam
    decl.gleam          # intermediate IR (ModuleDecl, FunctionDecl, BodyKind)
    encoder.gleam       # TypeDef ‚Üí Decl
    printer.gleam       # Decl ‚Üí Gleam source
    runner.gleam        # orchestration

sdk/                    # dagger_gleam ‚Äî the published SDK
  src/
    dagger.gleam        # public entrypoint (connect, Client)
    dagger/
      types.gleam       # runtime types (DaggerOp, Value, Try, ‚Ä¶)
      interpreter.gleam # eval/apply, recursive ID resolution
      client.gleam      # HTTP transport
      dsl/              # auto-generated by dgl generate
        dag.gleam       # root entry point
        container.gleam
        ‚Ä¶
    examples/           # runnable examples
  test/

.ci/                    # CI pipeline (Dagger, not published)
  src/ci.gleam
```

---

## Roadmap

- [x] Deferred execution engine
- [x] Recursive ID resolution for nested objects
- [x] DSL code generation from GraphQL introspection
- [x] CPS execution model (data separated from effects)
- [ ] Dagger Module support (writing Dagger Modules in Gleam)
- [ ] ID memoization within a single execution
- [ ] Published hex package

---

## Contributing

This project is in early development. PRs and issues are welcome.
